(* Testing of this code was done through calling print_debug on each function in
 * turn in many runs of the PokaBot and seeing whether the values met 
 * expectations of results, similar to testing in ps7.  Most of 
 * those print_debug statements have been removed in order to make the code more
 * readable, but our favorites remain *)

open Probs

module type POKABAYES =
sig
  type action = Fold | Call | Raise | Check | Bet | NoAct
  val string_of_action : action -> string
  val turn : int -> int -> action -> action -> int -> int -> action
end


module PokaBayes : POKABAYES =
struct
 
  (* Possible betting actions with "none" option for before the first action *)
  (* CONSIDER COMBINING CALL/CHECK AND RAISE/BET *)
  type action = Fold | Call | Raise | Check | Bet | NoAct

  (* Debugging function that allows printing float lists *)
  let string_of_float_list (flist: float list) : string = 
    List.fold_right (fun x y -> (string_of_float x)^"; "^y) flist ""

  (* Debugging function *)
  let print_debug s = 
    if Switches.debug_messages then prerr_endline ("PokaBayes: "^s)
    else ()   

  (* Function used by the game controller *)
  let string_of_action (a:action) : string = 
    match a with
    | Fold -> "FOLD"
    | Call -> "CALL"
    | Raise -> "RAISE"
    | Check -> "CHECK"
    | Bet -> "BET"
    | NoAct -> "NO ACT"

(* Useful exceptions for cases that break invariants *)
exception InvalidCPT
exception GameHasEnded
exception UnequalListLengthForSumColumns
exception IndexTooLarge
exception NoGoodActions

(* Extracts any probability from a float list when passed the correct place.  
 * Is actually just List.nth but with a more readable name *)
let extract_single_prob (lst: float list) (elt: int) : float =  List.nth lst elt

(* Infers bpp_final_hand probability table from bpp_current CPT and bpp_final 
 * probability table using Bayes rule.  Adds min_float to denom so that when the
 * numerator and denominator are both 0, the result will be 0 and the other 
 * calculations will be minimally if at all affected.  Raises InvalidCPT error 
 * on incorrect inputs *)
let gen_bpp_final_inf (round: int) (bpp_curr: int) 
(bopp_curr_cpt: (int list * float list) list) (bpp_final_pt: float list) : 
float list = 
  let nums,denom = 
    (List.fold_right
      (* x is a row of the CPT of format a,b with a being the inputs in the form
       * [current round;computer final hand type] and b being a list of the 
       * probabilities of the computer's current hand type *) 
      (fun x y -> let a,b = x in 
        match a with
        | [rd;final] -> 
          if rd = round 
          (* y is a tuple c,d of c = list of probabilities of each final hand 
           * type, d = sum of probabilities of each final hand type *)
          then let c,d = y in
            (* probi multiplies the probability of each possible final hand type
             * by the conditional probability of the computer's current hand 
             * type given the round and the final hand type.  List.fold_right 
             * ensures that we do this for each possible final hand type *)
            let probi = (extract_single_prob bpp_final_pt final)*.
                        (extract_single_prob b bpp_curr) in         
            (probi::c,probi+.d)
          else y
        (* It should never be passed a CPT with a different length of input 
         * list *)
        | _ -> raise InvalidCPT) 
    bopp_curr_cpt ([],0.)) in
  (* We then divide each probability in the generated list by min_float plus the
   * sum of the probabilities of all elements in the list. *)
  List.map (fun x -> x /. (denom+.min_float)) nums

(* Infers opp_final_hand probability table (not conditional) from opp_current 
 * CPT, opp_final CPT, and the table generated by gen_bpp_final_inf using Bayes 
 * rule.  Adds min_float to denom so that when the numerator and denominator are
 * both 0, the result will be 0 and the other calculations will be minimally if 
 * at all affected.  Raises InvalidCPT error on incorrect inputs *)
let gen_opp_final_inf (round: int) (opp_curr: int) 
(bopp_curr_cpt: (int list * float list) list) 
(opp_final_cpt: (int list * float list) list) (bpp_final_inf_pt: float list) : 
float list = 
  let nums,denom = 
    (List.fold_right 
      (* x is a row of the CPT of format a,b with a being the inputs in the form
       * [current round;human final hand type] and b being a list of the 
       * probabilities of the human's current hand type *) 
      (fun x y -> let a,b = x in
        match a with
        | [rd;final] -> 
          if rd = round
          (* y is a tuple c,d of c = list of probabilities of each final hand 
           * type, d = sum of probabilities of each final hand type *)
          then let c,d = y in
            (* probi multiplies (the conditional probability of the human's 
             * current hand type given the round and the human's final handtype)
             * by the sum of the probj's as described below.  List.fold_right 
             * ensures that we do this for each possible human final hand type*)
	    let probi = (extract_single_prob b opp_curr)*.
              (List.fold_right
                (* x1 is a row of the CPT of format e,f with e being the input 
                 * in the form [computer's final hand type] and f being a list 
                 * of the probabilities of the human's final handtype. *) 
                (fun x1 y1 -> let e,f = x1 in
                  match e with
	          | [bppfin] -> 
                    (* probj multiplies the conditional probability of the 
                     * human's final hand type given the computer's final hand 
                     * type by the inferred probability (from gen_bpp_final_inf)
                     * of the computer's final hand type.  List.fold_right 
                     * ensures that we do this for each possible computer final 
                     * hand type *)
                    let probj = (extract_single_prob f final)*.
                                (extract_single_prob bpp_final_inf_pt bppfin) in
                    y1+.probj
                  (* It should never be passed a CPT with a different length of 
                   * input list *)
	          | _ -> raise InvalidCPT) 
              opp_final_cpt 0.) in
            (probi::c,probi+.d)
          else y
        (* It should never be passed a CPT with a different length of input 
         * list *)
        | _ -> raise InvalidCPT) 
    bopp_curr_cpt ([],0.)) in
  (* We then divide each probability in the generated list by min_float plus the
   * sum of the probabilities of all elements in the list. *)
  List.map (fun x -> x /. (denom+.min_float)) nums

(* Converts actions to ints for use as indices in CPTs *)
let int_of_action (a:action) : int = 
  match a with
  | Fold -> 0
  | Call -> 1
  | Raise -> 2
  | Check -> 3
  | Bet -> 4
  | NoAct -> 5

(* Infers opp_current hand probability table (not conditional) from opp_action 
 * CPT, opp_current CPT, opp_final CPT, board CPT, and the table generated by 
 * gen_bpp_final_inf using Bayes rule.  Adds min_float to denom so that when the
 * numerator and denominator are both 0, the result will be 0 and the other 
 * calculations will be minimally if at all affected.  Raises InvalidCPT error 
 * on incorrect inputs *)
let gen_opp_curr_inf (round: int) (board: int) (bpp_past_act: action) 
(opp_act: action) (opp_act_cpt: (int list * float list) list) 
(opp_final_cpt: (int list * float list) list) (bpp_final_inf_pt: float list) 
(board_cpt: (int list * float list) list) 
(bopp_curr_cpt: (int list * float list) list) : float list = 
  let nums,denom = print_debug ("bpp_act = "^(string_of_action bpp_past_act)^
" and opp_act = "^(string_of_action opp_act));
    (List.fold_right 
      (* x is a row of the CPT of format a,b with a being the inputs in the form
       * [computer's past action;board hand type;human current hand type] and b 
       * being a list of the probabilities of the human's next action *) 
      (fun x y -> let a,b = x in
        match a with
        | [bpstact;brd;oppcur] ->
          if (brd = board) && (bpstact = (int_of_action bpp_past_act)) 
          (* y is a tuple c,d of c = list of probabilities of each final hand 
           * type, d = sum of probabilities of each final hand type *)
          then (let c,d = y in
            (* probi multiplies the probability of (the current board hand type 
             * given the round and the human's current hand type) by (the 
             * conditional probability of the human's most recent action given 
             * the computer's last action, the board's hand type, and the 
             * human's current handtype) by the sum of the probj's as described 
             * below.  List.fold_right ensures that we do this for each possible
             * human final hand type *)
            let probi = 
              (let r,s = 
                (* Selects the row of the Board CPT with the correct inputs *)
                (List.find 
                  (fun q -> let t,v = q in 
                    match t with
                    | [rd;opcu] -> (rd = round) && (opcu = oppcur)
                    | _ -> raise InvalidCPT) 
                board_cpt) in
              (* Extracts the correct entry from that row *) 
              extract_single_prob s board)*.
              (extract_single_prob b (int_of_action opp_act))*.
              (List.fold_right 
                (* x1 is a row of the CPT of format e,f with e being the input 
                 * in the form [current round;human's final hand type] and f 
                 * being a list of the probabilities of the human's current 
                 * handtype. *) 
                (fun x1 y1 -> let e,f = x1 in
                  match e with 
                  | [rnd;opfnl] -> 
                    if round = rnd 
                    then 
                      (* probj multiplies (the conditional probability of the 
                       * human's current hand type given the round and the 
                       * human's final hand type) by the sum of the probj's as 
                       * described below.  List.fold_right ensures that we do 
                       * this for each possible computer final hand type *)
                      let probj = (extract_single_prob f oppcur)*.
                        (List.fold_right 
                          (* x2 is a row of the CPT of format e,f with g being 
                           * the input in the form [computer's final hand type] 
                           * and h being a list of the probabilities of the 
                           * human's final handtype. *) 
                          (fun x2 y2 -> let g,h = x2 in
                            match g with
                            | [bppfin] -> 
                              (* probk multiplies the conditional probability of
                               * the human's final hand type given the 
                               * computer's final hand type by the inferred 
                               * probability (from gen_bpp_final_inf) of the 
                               * computer's final hand type.  List.fold_right 
                               * ensures that we do this for each possible 
                               * computer final hand type *)
                              let probk = (extract_single_prob h opfnl)*.
                                          (extract_single_prob bpp_final_inf_pt 
                                            bppfin) in 
                              y2+.probk
                            (* It should never be passed a CPT with a different 
                             * length of input list *)
                            | _ -> raise InvalidCPT)
                        opp_final_cpt 0.) in
                      probj+.y1
                    else y1
                  (* It should never be passed a CPT with a different length of 
                   * input list *)
                  | _ -> raise InvalidCPT) 
              bopp_curr_cpt 0.) in 
            (probi::c,probi+.d))
          else y
        (* It should never be passed a CPT with a different length of input 
         * list *)
        | _ -> raise InvalidCPT) 
      opp_act_cpt ([],0.)) in 
  (* We then divide each probability in the generated list by min_float plus the
   * sum of the probabilities of all elements in the list. *)
  List.map (fun x -> x /. (denom+.min_float)) nums

(* A variant of reduce that incorporates the index of the current list element, 
 * starting with hd = 0 *)
(* Thanks, Kevin Schmid for writing this function when I asked about the best 
 * way to do this on Piazza *)
let reduce_k_v f u xs = 
 let _, r = List.fold_left (fun (n, a) b -> (n + 1, f n a b)) (0,u) xs in r

(* Returns None when given two lists of unequal length.  When given two float 
 * lists of equal length, creates a third list lst of the same length by adding 
 * the entries in corresponding indices and returns Some lst.  Should only be 
 * called on lists of equal length in this usage.
 * E.g. sum_columns [1.;2.] [3.;5.] = Some [4.;7.] Based on the zip example from
 * class *)
let rec sum_columns (x: float list) (y: float list) : float list option =
  match x,y with
  |[],[] -> Some []
  |xhd::xtl,yhd::ytl -> (match sum_columns xtl ytl with 
                        | None -> None
			| Some ztl -> Some ((xhd+.yhd)::ztl))
  |(_,_) -> None

(* Only called after sum_columns.  Extracts an option value and calls the 
 * UnequalListLengthForSumColumns error if passed None. *)
let ret_opt_val (o: 'a option) : 'a =
  match o with
  | Some value -> value
  | None -> raise UnequalListLengthForSumColumns

(* Returns a pair (first n elements of lst, rest of elements of lst).  Taken 
 * from Bignums pset *)
let rec split (lst: 'a list) (n: int) =
  if n = 0 then ([], lst)
  else match lst with
    | [] -> ([], [])
    | h::t -> let (lst1, lst2) = split t (n-1) in
        (h::lst1, lst2)

(* Converts a split list into a triple by taking the first element of the second
 * part of the list and making it the middle element.  Raises the IndexTooLarge 
 * error if the second list in the tuple is an empty list. *)
let triple (splitted: 'a list * 'a list): 'a list * 'a * 'a list = 
  let fst,snd = splitted in
  match snd with
  | [] -> raise IndexTooLarge
  | hd :: tl -> (fst,hd,tl)

(* Sums the elements of a float list with indices less than n, equal to n, and 
 * greater than n in the form [less;equal;greater] *)
let less_equal_more (n: int) (opp_final_prob: float list) : float list = 
  let beg,mid,en = triple (split opp_final_prob n) in
  [(List.fold_right (+.) beg 0.);mid;(List.fold_right (+.) en 0.)]

(* Constructs the table (node) for outcome probabilities given the probabilities
 * of bpp and opp having each possible hand type by weighting (the results of 
 * calling less_equal_more on the list of probabilities of each possible 
 * opponent final handtype for each possible computer handtype) by the 
 * probability of the computer having that handtype *)
let prob_lose_tie_win (bpp_final_prob: float list) (opp_final_prob: float list) 
: float list = 
  List.fold_right 
    (fun x y -> (ret_opt_val (sum_columns x y))) 
    (reduce_k_v 
      (fun n curr_list weight -> 
        (List.map (( *. ) weight) (less_equal_more n opp_final_prob)) 
        :: curr_list) 
    [] bpp_final_prob) 
    [0.;0.;0.]

(* Given a float value f and a length n, generates a list of length n wherein 
 * each value is f *)
let rec gen_iden_float_list (fval: float) (len: int) : float list = 
  if len > 0
  then fval :: (gen_iden_float_list fval (len-1))
  else []

(* Given known information like current round, each player's prior action, and 
 * current board, uses the inference procedures above to calculate a probability
 * table (not conditional) of the human opponent's final hand.  Does this by 
 * using the inferred probability of each current hand as a weight for the 
 * corresponding table of probabilities of the opponent's final hand given that 
 * current hand.  Used in calculating the probability that the computer player 
 * wins/loses/ties *)
let opp_final_weighted (round: int) (board: int) (opp_act: action) 
(inf_curr: float list) (bopp_curr_cpt: (int list * float list) list) 
(opp_final_cpt: (int list * float list) list) (bpp_final_inf_pt: float list) =
  List.fold_right 
    (fun x y -> (ret_opt_val (sum_columns x y))) 
    (reduce_k_v 
      (fun n curr_list weight -> 
        (List.map (( *. ) weight) 
          (gen_opp_final_inf round n bopp_curr_cpt opp_final_cpt 
           bpp_final_inf_pt)) 
        :: curr_list) 
    [] inf_curr) 
    (gen_iden_float_list 0. 44)

(* This is a purely probabilistic (no inference on the opponent) calculation of 
 * the table of probabilities of each possible opponent's future hand.  It is 
 * used in calculating the probability of a win/loss/tie and as part of an 
 * alternate procedure for calculating the probability of the human opponent's 
 * future actions. This is used when the opponent has not taken an action thus 
 * far in the game, since prior actions are needed for inference.*)

(* It uses the probability of each computer's final hand given its current hand 
 * as a weight for the corresponding list of probabilities of human's final hand
 * given computer final hand and then sums *)
let opp_final_probab (bpp_final_inf_pt: float list) 
(opp_final_cpt: (int list * float list) list) = 
  List.fold_right (fun x y -> (ret_opt_val (sum_columns x y))) 
    (reduce_k_v 
      (fun n curr_list weight -> 
        (List.map (( *. ) weight) 
          (let r,s = 
            (List.find 
              (fun q -> let t,v = q in 
                match t with
	        | [inp] -> (inp = n)
	        | _ -> raise InvalidCPT) 
            opp_final_cpt) 
          in s)) 
      :: curr_list) 
    [] bpp_final_inf_pt) 
    (gen_iden_float_list 0. 44)

(* This is a purely probabilistic (no inference on the opponent) calculation of
 * the table of probabilities of each possible opponent's future hand.  It is 
 * used as part of an alternate procedure for calculating the probability of the
 * human opponent's future actions. This is used when the opponent has not taken
 * an action thus far in the game, since prior actions are needed for 
 * inference. *)

(* It uses the probability of each human's final hand (from opp_final_probab) as
 * a weight for the corresponding list of probabilities of human's current hand
 * given final hand and then sums *)
let opp_curr_probab (opp_final_fwd_pt: float list) (round: int)
(opp_curr_cpt: (int list * float list) list) =
  List.fold_right 
    (fun x y -> (ret_opt_val (sum_columns x y))) 
      (reduce_k_v 
        (fun n curr_list weight -> 
          (List.map (( *. ) weight) 
            (let r,s = 
              (List.find 
                (fun q -> let t,v = q in 
                  match t with
	          | [rd;oppfin] -> (oppfin = n) && (rd = round)
	          | _ -> raise InvalidCPT) 
              opp_curr_cpt) 
            in s))
      :: curr_list) 
    [] opp_final_fwd_pt) 
    (gen_iden_float_list 0. 44)


(* This calculates the probability of an opponent's next action given a table of
 * probabilities of their current hand, the opp_act CPT, the round, the board, 
 * and the computer player's last action.  It uses the probability of the 
 * human's current hand as a weight for the corresponding list of probabilities 
 * of next action and then sums *)
let prob_future_act (round: int) (curr: float list) 
(opp_act_cpt: (int list * float list) list) (board: int) (bpp_prev_act: action) 
: float list =
  List.fold_right 
    (fun x y -> (ret_opt_val (sum_columns x y))) 
      (reduce_k_v 
        (fun n curr_list weight -> 
          (List.map (( *. ) weight) 
	    (let r,s = 
              (List.find 
                (fun q -> let r,s = q in 
	          match r with
	          | [bpstact;brd;oppcur] -> (brd = board) && 
                                        (bpstact = (int_of_action bpp_prev_act))
                                         && (oppcur = n)
	          | _ -> raise InvalidCPT)
	      opp_act_cpt) 
	    in s)) 
      :: curr_list) 
    [] curr) 
    [0.;0.;0.;0.;0.;0.]

(* Finds the largest value in a float list and retrieves both it and its index. 
 * Used to determine the action of highest utility *)
let index_and_val_of_greatest_in_list (lst: float list) : (float*int) = 
  reduce_k_v (fun n highest prob -> 
  let (high_val,high_n) = highest in 
  if prob >= high_val
  then (prob,n)
  else highest) ((float_of_int (min_int)),(-1)) lst

(* Converts the index to the appropriate action.  Raises the error NoGoodActions
 * if the number is anything other than 0-4 *)
let action_of_highest_ev_given_index (n:int) : action =
  match n with
  | 0 -> Fold
  | 1 -> Call
  | 2 -> Raise
  | 3 -> Check
  | 4 -> Bet
  | _ -> raise NoGoodActions

(* The function that puts this all together determines the action with the 
 * highest EV.  Raises GameHasEnded exception if passed Fold *)
let turn (bpp_hand: int) (round: int) (bpp_prev_act: action) 
(opp_prev_act: action) (board: int) (pot: int) : action = 

  (* Working with floats *)
  let fpot = float_of_int pot in

  (* This will never have the highest utility - used for illegal moves *)
  let imp = 0./.0. in

  (* Assemble multipart CPTs *)
  let bopp_curr_cpt = Probs.bpp_ftc_1@Probs.bpp_ftc_2@Probs.bpp_ftc_3@
    Probs.bpp_ftc_4 in
  let board_pt = Probs.boardpt1@Probs.boardpt2@Probs.boardpt3@Probs.boardpt4 in

  (* Inferred probabilities of computer final hand given computer current 
   * hand *)
  let inf_good = gen_bpp_final_inf round bpp_hand bopp_curr_cpt Probs.final in

  let lst = (match opp_prev_act with

  (* If the human's prior action was NoAct *)
  | NoAct ->   

    (* Non-inferred probabilities of opponent's final hand *)
    let opfinprob = opp_final_probab inf_good Probs.oppfinalpt in

    (* Non-inferred probabilities of opponent's current hand *)
    let opcurrprob = opp_curr_probab opfinprob round bopp_curr_cpt in

    (* Probabilities that the computer wins, loses, and ties *)
    let no_act_lose_tie_win = prob_lose_tie_win inf_good opfinprob  in

    (* Probabilities of opponent's future actions if the computer checks *)
    let no_act_future_given_check = prob_future_act round opcurrprob 
      Probs.opp_act board Check in

    (* Probabilities of opponent's future actions if the computer bets *)
    let no_act_future_given_bet = prob_future_act round
      (opp_curr_probab opfinprob round bopp_curr_cpt) Probs.opp_act board Bet in

    (* Extracts probabilities of win, tie, and loss, respectively *)
    let na_win_prob = extract_single_prob no_act_lose_tie_win 2 in
    let na_tie_prob = extract_single_prob no_act_lose_tie_win 1 in
    let na_lose_prob = extract_single_prob no_act_lose_tie_win 0 in
    print_debug("win_prob = "^(string_of_float na_win_prob)^" and tie_prob = "^
    (string_of_float na_tie_prob)^" and lose_prob = "^
    (string_of_float na_lose_prob));

    (* Extracts probabilities of the opponent raising, betting, and calling, 
     * respectively.  No probabilities are given for fold or call because the 
     * cost of each of these actions, by which their probabilities are 
     * multiplied, is 0. *)
    let na_raise_prob = extract_single_prob no_act_future_given_bet 2 in
    let na_bet_prob = extract_single_prob no_act_future_given_check 4 in
    let na_call_prob = extract_single_prob no_act_future_given_bet 1 in
    print_debug("raise_prob = "^(string_of_float na_raise_prob)^
    " and bet_prob = "^(string_of_float na_bet_prob)^" and call_prob = "^
    (string_of_float na_call_prob));

      (* Always get nothing if you fold *)
      [0.;

      (* Can't call or raise nothing *)
      imp;imp;
      
      (* If you check, you spend 0 and they can check, bet, or fold *)
      ((fpot+.na_bet_prob)*.na_win_prob)+.((fpot+.na_bet_prob)*.
      na_tie_prob/.2.);

     (* If you bet, you spend 1 and they can call, raise, or fold *) 
      ((fpot+.1.+.na_call_prob+.(2.*.na_raise_prob))*.na_win_prob)+.((fpot+.1.+.
      na_call_prob+.(2.*.na_raise_prob))*.na_tie_prob/.2.)+.((-1.)*.
      na_lose_prob)]

  (* If the human's prior action was a Call - This is equivalent to a NoAct in 
   * terms of legal moves, except that it's in the middle of a game, so we can 
   * use inference *) 
  | Call ->

    (* Inferred probability of opponent current hand types *)
    let inf_curr = gen_opp_curr_inf round board bpp_prev_act opp_prev_act 
      Probs.opp_act Probs.oppfinalpt inf_good board_pt bopp_curr_cpt in
    print_debug("inf_curr is: "^(string_of_float_list inf_curr));

    (* probabilities of loss, win, and tie for the computer *)
    let lose_tie_win = 
      let opp_fin_w = (opp_final_weighted round board opp_prev_act inf_curr 
        bopp_curr_cpt Probs.oppfinalpt inf_good) in 
      prob_lose_tie_win inf_good opp_fin_w in

    (* Probabilities of the opponent's future actions if the computer bets *)
    let future_given_bet = prob_future_act round inf_curr Probs.opp_act board 
      Bet in

    (* Probabilities of the opponent's future actions if the computer checks *)
    let future_given_check = prob_future_act round inf_curr Probs.opp_act board 
      Check in

    (* Extracts probabilities of win, tie, and loss, respectively *)
    let win_prob = extract_single_prob lose_tie_win 2 in
    let tie_prob = extract_single_prob lose_tie_win 1 in
    let lose_prob = extract_single_prob lose_tie_win 0 in
    print_debug("win_prob = "^(string_of_float win_prob)^" and tie_prob = "^
    (string_of_float tie_prob)^" and lose_prob = "^(string_of_float lose_prob));

    (* Extracts probabilities of the opponent raising, betting, and calling, 
     * respectively.  No probabilities are given for fold or call because the 
     * cost of each of these actions, by which their probabilities are 
     * multiplied, is 0. *)
    let raise_prob = extract_single_prob future_given_bet 2 in
    let bet_prob = extract_single_prob future_given_check 4 in
    let call_prob = extract_single_prob future_given_bet 1 in
    print_debug("raise_prob = "^(string_of_float raise_prob)^"and bet_prob = "^
    (string_of_float bet_prob)^" and call_prob = "^(string_of_float call_prob));

      (* Always get nothing if you fold *)
      [0.;

      (* Can't call or raise nothing *)
      imp;imp;
      
      (* If you check, you spend 0 and they can check, bet, or fold *)
      ((fpot+.bet_prob)*.win_prob)+.((fpot+.bet_prob)*.tie_prob/.2.);

     (* If you bet, you spend 1 and they can call, raise, or fold *) 
      ((fpot+.1.+.call_prob+.(2.*.raise_prob))*.win_prob)+.((fpot+.1.+.call_prob
      +.(2.*.raise_prob))*.tie_prob/.2.)+.((-1.)*.lose_prob)]

  (* If the human's prior action was a Check *)
  | Check -> 

    (* Inferred probability of opponent current hand types *)
    let inf_curr = gen_opp_curr_inf round board bpp_prev_act opp_prev_act 
      Probs.opp_act Probs.oppfinalpt inf_good board_pt bopp_curr_cpt in
    print_debug("inf_curr is: "^(string_of_float_list inf_curr));

    (* probabilities of loss, win, and tie for the computer *)
    let lose_tie_win = 
      let opp_fin_w = (opp_final_weighted round board opp_prev_act inf_curr 
        bopp_curr_cpt Probs.oppfinalpt inf_good) in 
      prob_lose_tie_win inf_good opp_fin_w in

    (* Probabilities of the opponent's future actions if the computer bets *)
    let future_given_bet = prob_future_act round inf_curr Probs.opp_act board 
      Bet in

    (* Extracts probabilities of win, tie, and loss, respectively *)
    let win_prob = extract_single_prob lose_tie_win 2 in
    let tie_prob = extract_single_prob lose_tie_win 1 in
    let lose_prob = extract_single_prob lose_tie_win 0 in
    print_debug("win_prob = "^(string_of_float win_prob)^" and tie_prob = "^
    (string_of_float tie_prob)^" and lose_prob = "^(string_of_float lose_prob));

    (* Extracts probabilities of the opponent raising and calling , 
     * respectively.  No probabilities are given for fold or call because the 
     * cost of each of these actions, by which their probabilities are 
     * multiplied, is 0. No probability is given for bet because this cannot 
     * happen *)
    let raise_prob = extract_single_prob future_given_bet 2 in
    let call_prob = extract_single_prob future_given_bet 1 in
    print_debug("raise_prob = "^(string_of_float raise_prob)^" and call_prob = "
    ^(string_of_float call_prob));

     (* Always get nothing if you fold *)
      [0.;

      (* Can't call or raise a check *)
      imp;imp;

      (* If you check, you spend 0 and the round ends *)
      (fpot*.win_prob)+.(fpot*.tie_prob/.2.);

      (* If you bet, you spend 1 and they can call, raise, or fold *)
      ((fpot+.1.+.call_prob+.(2.*.raise_prob))*.win_prob)+.((fpot+.1.+.call_prob
      +.(2.*.raise_prob))*.tie_prob/.2.)+.((-1.)*.lose_prob)]

  (* If the human's prior action was a Check *)
  | Raise | Bet -> 

    (* Inferred probability of opponent current hand types *)
    let inf_curr = gen_opp_curr_inf round board bpp_prev_act opp_prev_act 
      Probs.opp_act Probs.oppfinalpt inf_good board_pt bopp_curr_cpt in
    print_debug("inf_curr is: "^(string_of_float_list inf_curr));

    (* probabilities of loss, win, and tie for the computer *)
    let lose_tie_win = 
      let opp_fin_w = (opp_final_weighted round board opp_prev_act inf_curr 
        bopp_curr_cpt Probs.oppfinalpt inf_good) in 
      prob_lose_tie_win inf_good opp_fin_w in

    (* Probabilities of the opponent's future actions if the computer raises *)
    let future_given_raise = prob_future_act round inf_curr Probs.opp_act board 
      Raise in

    (* Extracts probabilities of win, tie, and loss, respectively *)
    let win_prob = extract_single_prob lose_tie_win 2 in
    let tie_prob = extract_single_prob lose_tie_win 1 in
    let lose_prob = extract_single_prob lose_tie_win 0 in
    print_debug("win_prob = "^(string_of_float win_prob)^" and tie_prob = "^
    (string_of_float tie_prob)^" and lose_prob = "^(string_of_float lose_prob));

    (* Extracts probabilities of the opponent raising and calling , 
     * respectively.  No probabilities are given for fold or call because the 
     * cost of each of these actions, by which their probabilities are 
     * multiplied, is 0. No probability is given for bet because this cannot 
     * happen *)
    let raise_prob = extract_single_prob future_given_raise 2 in
    let call_prob = extract_single_prob future_given_raise 1 in
    print_debug("raise_prob = "^(string_of_float raise_prob)^" and call_prob = "
    ^(string_of_float call_prob));

      (* Always get nothing if you fold *)
      [0.;

      (* If you call, you spend 1 and the round ends *)
      ((fpot+.1.)*.win_prob)+.((fpot+.1.)*.tie_prob/.2.)+.((-1.)*.lose_prob);

      (* If you raise, you spend 2 and they can call, raise, or fold *)
      ((fpot+.2.+.call_prob+.(2.*.raise_prob))*.win_prob)+.((fpot+.2.+.call_prob
      +.(2.*.raise_prob))*.tie_prob/.2.)+.((-2.)*.lose_prob);

      (* Can't check or bet on a bet/raise *)
      imp;imp]

  (* The opponent's prior action was a Fold *)
  | _ -> raise GameHasEnded) in

  (* Extracts and returns the action with highest expected value *)
  let value,ind = index_and_val_of_greatest_in_list lst in
    print_debug ("From the utility list: "^(string_of_float_list lst)^
    " the computer selects index "^(string_of_int ind)^" with value "^
    (string_of_float value));
  action_of_highest_ev_given_index ind
 
end
